# Maze_Solver_BFSapplication
served as a quick and easy review of BFS. Logic is a bit messy as I was implementing trees in python; However, it basically uses queues and trees to traverse back and forth and to find the minimum path.

Basically finds the shortest path of any maze given that the start and end positions are defined.
- Design the test case in test.py (Can be of any dimensions)
- "S" and "E" must exist for it to work
- Must use "#" for walls and " " for empty space

## Example of a test case (can be of any dimensions/design/Visualized in terminal):
<img src = "https://github.com/yvielcastillejos/Maze_Solver_BFSapplication/blob/master/Screen%20Shot%202020-10-15%20at%203.29.13%20AM.png" height = "250" width = "250">
 
 ## Visualization of testcase using pygame:
<img src = "https://github.com/yvielcastillejos/Maze_Solver_BFSapplication/blob/master/BFS.png" height = "550" width = "350">


## The result (In the terminal):
<img src = "https://github.com/yvielcastillejos/Maze_Solver_BFSapplication/blob/master/Screen%20Shot%202020-10-15%20at%203.48.53%20AM.png" height = "250" width = "250">

## We can visualize this with pygame

<img src = "https://github.com/yvielcastillejos/Maze_Solver_BFSapplication/blob/master/BFS.gif" height = "550" width = "350">


## Next step
- Visualize how BFS really works by showing the visited blocks and how head position "looks" for the end or "E"
